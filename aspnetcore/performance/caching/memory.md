---
title: Кэширование в памяти в ASP.NET Core
author: rick-anderson
description: Узнайте, как кэшировать данные в памяти в ASP.NET Core.
ms.author: riande
ms.custom: mvc
ms.date: 02/02/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: performance/caching/memory
ms.openlocfilehash: d71678aeee9b3fca717129a2fbed1f75b593e010
ms.sourcegitcommit: 54fe1ae5e7d068e27376d562183ef9ddc7afc432
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/10/2021
ms.locfileid: "102586310"
---
# <a name="cache-in-memory-in-aspnet-core"></a><span data-ttu-id="671c6-103">Кэширование в памяти в ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="671c6-103">Cache in-memory in ASP.NET Core</span></span>

::: moniker range=">= aspnetcore-3.0"

<span data-ttu-id="671c6-104">[Рик Андерсон (](https://twitter.com/RickAndMSFT), [Джон Луо](https://github.com/JunTaoLuo)и [Стив Смит](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="671c6-104">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="671c6-105">[Просмотреть или скачать образец кода](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/performance/caching/memory/3.0sample) ([как скачивать](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="671c6-105">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/performance/caching/memory/3.0sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="671c6-106">Основы кэширования</span><span class="sxs-lookup"><span data-stu-id="671c6-106">Caching basics</span></span>

<span data-ttu-id="671c6-107">Кэширование может значительно повысить производительность и масштабируемость приложения, уменьшая объем работы, необходимый для создания содержимого.</span><span class="sxs-lookup"><span data-stu-id="671c6-107">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="671c6-108">Кэширование лучше всего работает с данными, которые изменяются редко **и** требуют больших затрат.</span><span class="sxs-lookup"><span data-stu-id="671c6-108">Caching works best with data that changes infrequently **and** is expensive to generate.</span></span> <span data-ttu-id="671c6-109">Кэширование создает копию данных, которая может быть возвращена гораздо быстрее, чем из источника.</span><span class="sxs-lookup"><span data-stu-id="671c6-109">Caching makes a copy of data that can be returned much faster than from the source.</span></span> <span data-ttu-id="671c6-110">Приложения должны быть написаны и протестированы, чтобы **никогда не** зависеть от кэшированных данных.</span><span class="sxs-lookup"><span data-stu-id="671c6-110">Apps should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="671c6-111">ASP.NET Core поддерживает несколько разных кэшей.</span><span class="sxs-lookup"><span data-stu-id="671c6-111">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="671c6-112">Простейший кэш основан на [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span><span class="sxs-lookup"><span data-stu-id="671c6-112">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span></span> <span data-ttu-id="671c6-113">`IMemoryCache` Представляет кэш, хранящийся в памяти веб-сервера.</span><span class="sxs-lookup"><span data-stu-id="671c6-113">`IMemoryCache` represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="671c6-114">Приложения, работающие на ферме серверов (несколько серверов), должны обеспечивать работу сеансов при использовании кэша в памяти.</span><span class="sxs-lookup"><span data-stu-id="671c6-114">Apps running on a server farm (multiple servers) should ensure sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="671c6-115">Закрепленные сеансы гарантируют, что последующие запросы от клиента отправляются на один и тот же сервер.</span><span class="sxs-lookup"><span data-stu-id="671c6-115">Sticky sessions ensure that subsequent requests from a client all go to the same server.</span></span> <span data-ttu-id="671c6-116">Например, веб-приложения Azure используют [маршрутизацию запросов приложений](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) для маршрутизации всех последующих запросов к тому же серверу.</span><span class="sxs-lookup"><span data-stu-id="671c6-116">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all subsequent requests to the same server.</span></span>

<span data-ttu-id="671c6-117">Для неприкрепленных сеансов в веб-ферме требуется [распределенный кэш](distributed.md) , чтобы избежать проблем с согласованностью кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-117">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="671c6-118">Для некоторых приложений распределенный кэш может поддерживать более высокие возможности масштабирования, чем кэш в памяти.</span><span class="sxs-lookup"><span data-stu-id="671c6-118">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="671c6-119">Использование распределенного кэша разгружает кэш-память во внешний процесс.</span><span class="sxs-lookup"><span data-stu-id="671c6-119">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="671c6-120">Кэш в памяти может хранить любой объект.</span><span class="sxs-lookup"><span data-stu-id="671c6-120">The in-memory cache can store any object.</span></span> <span data-ttu-id="671c6-121">Интерфейс распределенного кэша ограничен `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="671c6-121">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="671c6-122">Элементы кэша в памяти и распределенного кэша хранятся в виде пар "ключ-значение".</span><span class="sxs-lookup"><span data-stu-id="671c6-122">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="671c6-123">System. Runtime. Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="671c6-123">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="671c6-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([Пакет NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) можно использовать с:</span><span class="sxs-lookup"><span data-stu-id="671c6-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="671c6-125">.NET Standard 2,0 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="671c6-125">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="671c6-126">Любая [реализация .NET](/dotnet/standard/net-standard#net-implementation-support) , предназначенная для .NET Standard 2,0 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="671c6-126">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="671c6-127">Например, ASP.NET Core 2,0 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="671c6-127">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="671c6-128">.NET Framework 4.5 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="671c6-128">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="671c6-129">[Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (описывается в этой статье) рекомендуется использовать, `System.Runtime.Caching` / `MemoryCache` так как он лучше интегрирован в ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="671c6-129">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="671c6-130">Например, `IMemoryCache` работает изначально с [внедрением зависимостей](xref:fundamentals/dependency-injection)ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="671c6-130">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="671c6-131">Используйте `System.Runtime.Caching` / `MemoryCache` в качестве моста совместимости при переносе кода из ASP.NET 4. x в ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="671c6-131">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="671c6-132">Рекомендации по кэшированию</span><span class="sxs-lookup"><span data-stu-id="671c6-132">Cache guidelines</span></span>

* <span data-ttu-id="671c6-133">Код должен всегда иметь резервный вариант для выборки данных и **не** зависит от доступности кэшированного значения.</span><span class="sxs-lookup"><span data-stu-id="671c6-133">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="671c6-134">Кэш использует неограниченный ресурс, память.</span><span class="sxs-lookup"><span data-stu-id="671c6-134">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="671c6-135">Ограничение роста кэша:</span><span class="sxs-lookup"><span data-stu-id="671c6-135">Limit cache growth:</span></span>
  * <span data-ttu-id="671c6-136">**Не** используйте внешние входные данные в качестве ключей кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-136">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="671c6-137">Используйте срок действия, чтобы ограничить рост кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-137">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="671c6-138">[Используйте SetSize, Size и сизелимит для ограничения размера кэша](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="671c6-138">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="671c6-139">Среда выполнения ASP.NET Core не **ограничивает размер** кэша на основе нехватки памяти.</span><span class="sxs-lookup"><span data-stu-id="671c6-139">The ASP.NET Core runtime does **not** limit cache size based on memory pressure.</span></span> <span data-ttu-id="671c6-140">Разработчик может ограничить размер кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-140">It's up to the developer to limit cache size.</span></span>

## <a name="use-imemorycache"></a><span data-ttu-id="671c6-141">Использование IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="671c6-141">Use IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="671c6-142">Использование кэша *общей* памяти из [внедрения зависимостей](xref:fundamentals/dependency-injection) и вызова `SetSize` , `Size` или `SizeLimit` для ограничения размера кэша может привести к сбою приложения.</span><span class="sxs-lookup"><span data-stu-id="671c6-142">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="671c6-143">Если для кэша задано ограничение размера, все записи должны указывать размер при добавлении.</span><span class="sxs-lookup"><span data-stu-id="671c6-143">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="671c6-144">Это может привести к проблемам, так как разработчики могут не иметь полного контроля над тем, что использует общий кэш.</span><span class="sxs-lookup"><span data-stu-id="671c6-144">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="671c6-145">Например, Entity Framework Core использует общий кэш и не задает размер.</span><span class="sxs-lookup"><span data-stu-id="671c6-145">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="671c6-146">Если приложение устанавливает ограничение размера кэша и использует EF Core, приложение создает исключение `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="671c6-146">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="671c6-147">При использовании `SetSize` , `Size` или `SizeLimit` для ограничения кэша создайте одноэлементный кэш для кэширования.</span><span class="sxs-lookup"><span data-stu-id="671c6-147">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="671c6-148">Дополнительные сведения и пример см. в статьях [Использование SetSize, Size и сизелимит для ограничения размера кэша](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="671c6-148">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>
> <span data-ttu-id="671c6-149">Общий кэш является общим для других платформ или библиотек.</span><span class="sxs-lookup"><span data-stu-id="671c6-149">A shared cache is one shared by other frameworks or libraries.</span></span> <span data-ttu-id="671c6-150">Например, EF Core использует общий кэш и не задает размер.</span><span class="sxs-lookup"><span data-stu-id="671c6-150">For example, EF Core uses the shared cache and does not specify a size.</span></span> 

<span data-ttu-id="671c6-151">Кэширование в памяти — это *Служба* , на которую ссылается приложение, использующее [внедрение зависимостей](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="671c6-151">In-memory caching is a *service* that's referenced from an app using [Dependency Injection](xref:fundamentals/dependency-injection).</span></span> <span data-ttu-id="671c6-152">Запросите `IMemoryCache` экземпляр в конструкторе:</span><span class="sxs-lookup"><span data-stu-id="671c6-152">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="671c6-153">В следующем коде используется [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) для проверки, находится ли время в кэше.</span><span class="sxs-lookup"><span data-stu-id="671c6-153">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="671c6-154">Если время не кэшировано, создается новая запись и добавляется в кэш с помощью [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="671c6-154">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span> <span data-ttu-id="671c6-155">`CacheKeys`Класс является частью примера загрузки.</span><span class="sxs-lookup"><span data-stu-id="671c6-155">The `CacheKeys` class is part of the download sample.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/CacheKeys.cs)]

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="671c6-156">Текущее время и кэшированное время отображаются:</span><span class="sxs-lookup"><span data-stu-id="671c6-156">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/3.0sample/WebCacheSample/Views/Home/Cache.cshtml)]

<span data-ttu-id="671c6-157">Следующий код использует метод расширения [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_System_TimeSpan_) для кэширования данных в относительное время без создания `MemoryCacheEntryOptions` объекта.</span><span class="sxs-lookup"><span data-stu-id="671c6-157">The following code uses the [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_System_TimeSpan_) extension method to cache data for a relative time without creating the `MemoryCacheEntryOptions` object.</span></span>
[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_set)]

<span data-ttu-id="671c6-158">Кэшированное `DateTime` значение остается в кэше во время выполнения запросов в течение периода ожидания.</span><span class="sxs-lookup"><span data-stu-id="671c6-158">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span>

<span data-ttu-id="671c6-159">В следующем коде для кэширования данных используются [жеторкреате](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) и [жеторкреатеасинк](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) .</span><span class="sxs-lookup"><span data-stu-id="671c6-159">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="671c6-160">Следующий код вызывает [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) для получения кэшированного времени:</span><span class="sxs-lookup"><span data-stu-id="671c6-160">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="671c6-161">Следующий код возвращает или создает кэшированный элемент с абсолютным сроком действия:</span><span class="sxs-lookup"><span data-stu-id="671c6-161">The following code gets or creates a cached item with absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet99)]

<span data-ttu-id="671c6-162">Набор кэшированных элементов с скользящим сроком действия может быть только устаревшим.</span><span class="sxs-lookup"><span data-stu-id="671c6-162">A cached item set with a sliding expiration only is at risk of becoming stale.</span></span> <span data-ttu-id="671c6-163">Если доступ к нему осуществляется чаще, чем скользящий интервал срока действия, срок действия элемента никогда не истечет.</span><span class="sxs-lookup"><span data-stu-id="671c6-163">If it's accessed more frequently than the sliding expiration interval, the item will never expire.</span></span> <span data-ttu-id="671c6-164">Объедините скользящий срок действия с абсолютным сроком действия, чтобы гарантировать, что срок действия элемента истекает по истечении его абсолютного срока действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-164">Combine a sliding expiration with an absolute expiration to guarantee that the item expires once its absolute expiration time passes.</span></span> <span data-ttu-id="671c6-165">Абсолютный срок действия задает верхнюю границу того, как долго элемент может быть кэширован, в то же время допуская окончания срока действия элемента, если он не запрашивался в течение скользящего интервала истечения.</span><span class="sxs-lookup"><span data-stu-id="671c6-165">The absolute expiration sets an upper bound to how long the item can be cached while still allowing the item to expire earlier if it isn't requested within the sliding expiration interval.</span></span> <span data-ttu-id="671c6-166">Если указан как абсолютный, так и скользящий срок действия, истечение срока действия логически ORed.</span><span class="sxs-lookup"><span data-stu-id="671c6-166">When both absolute and sliding expiration are specified, the expirations are logically ORed.</span></span> <span data-ttu-id="671c6-167">Если либо скользящий интервал истечения срока действия, *либо* период абсолютного окончания срока действия, элемент удаляется из кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-167">If either the sliding expiration interval *or* the absolute expiration time pass, the item is evicted from the cache.</span></span>

<span data-ttu-id="671c6-168">Следующий код возвращает или создает кэшированный элемент со скользящим *и* абсолютным сроком действия:</span><span class="sxs-lookup"><span data-stu-id="671c6-168">The following code gets or creates a cached item with both sliding *and* absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet9)]

<span data-ttu-id="671c6-169">Приведенный выше код гарантирует, что данные не будут кэшироваться дольше, чем абсолютное время.</span><span class="sxs-lookup"><span data-stu-id="671c6-169">The preceding code guarantees the data will not be cached longer than the absolute time.</span></span>

<span data-ttu-id="671c6-170"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>методы, и <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> являются методами расширения в <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> классе.</span><span class="sxs-lookup"><span data-stu-id="671c6-170"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> are extension methods in the <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> class.</span></span> <span data-ttu-id="671c6-171">Эти методы расширяют возможности <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="671c6-171">These methods extend the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="671c6-172">меморикачинтрйоптионс</span><span class="sxs-lookup"><span data-stu-id="671c6-172">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="671c6-173">Следующий пример:</span><span class="sxs-lookup"><span data-stu-id="671c6-173">The following sample:</span></span>

* <span data-ttu-id="671c6-174">Задает скользящий срок действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-174">Sets a sliding expiration time.</span></span> <span data-ttu-id="671c6-175">Запросы, обращающиеся к этому кэшированному элементу, будут сбрасывать скользящий срок действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-175">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="671c6-176">Задает приоритет кэша для [качеитемприорити. неверремове](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span><span class="sxs-lookup"><span data-stu-id="671c6-176">Sets the cache priority to [CacheItemPriority.NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span></span>
* <span data-ttu-id="671c6-177">Задает [постевиктионделегате](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) , который будет вызываться после удаления записи из кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-177">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="671c6-178">Обратный вызов выполняется в другом потоке из кода, который удаляет элемент из кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-178">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="671c6-179">Использование SetSize, Size и Сизелимит для ограничения размера кэша</span><span class="sxs-lookup"><span data-stu-id="671c6-179">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="671c6-180">`MemoryCache`Экземпляр может дополнительно задавать и применять ограничение размера.</span><span class="sxs-lookup"><span data-stu-id="671c6-180">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="671c6-181">Ограничение размера кэша не имеет определенной единицы измерения, так как кэш не имеет механизма для измерения размера записей.</span><span class="sxs-lookup"><span data-stu-id="671c6-181">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="671c6-182">Если установлен предел размера кэша, то для всех записей должен быть указан размер.</span><span class="sxs-lookup"><span data-stu-id="671c6-182">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="671c6-183">Среда выполнения ASP.NET Core не ограничивает размер кэша на основе нехватки памяти.</span><span class="sxs-lookup"><span data-stu-id="671c6-183">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="671c6-184">Разработчик может ограничить размер кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-184">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="671c6-185">Указанный размер находится в единицах, которые выбирает разработчик.</span><span class="sxs-lookup"><span data-stu-id="671c6-185">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="671c6-186">Пример:</span><span class="sxs-lookup"><span data-stu-id="671c6-186">For example:</span></span>

* <span data-ttu-id="671c6-187">Если веб-приложение в основном кэширует строки, каждый размер записи кэша может быть длиной строки.</span><span class="sxs-lookup"><span data-stu-id="671c6-187">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="671c6-188">Приложение может указать размер всех записей как 1, а максимальный размер — число записей.</span><span class="sxs-lookup"><span data-stu-id="671c6-188">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="671c6-189">Если <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> значение не задано, кэш растет без привязки.</span><span class="sxs-lookup"><span data-stu-id="671c6-189">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> isn't set, the cache grows without bound.</span></span> <span data-ttu-id="671c6-190">Среда выполнения ASP.NET Core не обрезает кэш при нехватке системной памяти.</span><span class="sxs-lookup"><span data-stu-id="671c6-190">The ASP.NET Core runtime doesn't trim the cache when system memory is low.</span></span> <span data-ttu-id="671c6-191">Приложения должны быть спроектированы следующим образом:</span><span class="sxs-lookup"><span data-stu-id="671c6-191">Apps must be architected to:</span></span>

* <span data-ttu-id="671c6-192">Ограничение роста кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-192">Limit cache growth.</span></span>
* <span data-ttu-id="671c6-193">Вызов <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> или <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> Если доступная память ограничена:</span><span class="sxs-lookup"><span data-stu-id="671c6-193">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="671c6-194">В следующем коде создается фиксированный размер независимого <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> от единицы, доступный при [внедрении зависимостей](xref:fundamentals/dependency-injection):</span><span class="sxs-lookup"><span data-stu-id="671c6-194">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="671c6-195">`SizeLimit` не имеет единиц.</span><span class="sxs-lookup"><span data-stu-id="671c6-195">`SizeLimit` does not have units.</span></span> <span data-ttu-id="671c6-196">Кэшированные записи должны указывать размер в любых единицах, которые они считаются наиболее подходящими, если установлен предел размера кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-196">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="671c6-197">Все пользователи экземпляра кэша должны использовать одну и ту же систему единиц измерения.</span><span class="sxs-lookup"><span data-stu-id="671c6-197">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="671c6-198">Запись не будет кэшироваться, если сумма кэшированных размеров записей превышает значение, заданное параметром `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="671c6-198">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="671c6-199">Если ограничение размера кэша не задано, размер кэша, заданный для записи, будет проигнорирован.</span><span class="sxs-lookup"><span data-stu-id="671c6-199">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="671c6-200">Следующий код регистрируется в `MyMemoryCache` контейнере [внедрения зависимостей](xref:fundamentals/dependency-injection) .</span><span class="sxs-lookup"><span data-stu-id="671c6-200">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Startup.cs?name=snippet)]

<span data-ttu-id="671c6-201">`MyMemoryCache` создается как независимый кэш памяти для компонентов, которые знают об этом ограниченном размере кэша и знают, как задать размер записи кэша соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="671c6-201">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="671c6-202">В следующем коде используется `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="671c6-202">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet)]

<span data-ttu-id="671c6-203">Размер записи кэша может быть задан <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> или <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> методами расширения:</span><span class="sxs-lookup"><span data-stu-id="671c6-203">The size of the cache entry can be set by <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> or the <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> extension methods:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="671c6-204">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="671c6-204">MemoryCache.Compact</span></span>

<span data-ttu-id="671c6-205">`MemoryCache.Compact` пытается удалить указанный процент кэша в следующем порядке:</span><span class="sxs-lookup"><span data-stu-id="671c6-205">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="671c6-206">Все элементы с истекшим сроком действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-206">All expired items.</span></span>
* <span data-ttu-id="671c6-207">Элементы по приоритету.</span><span class="sxs-lookup"><span data-stu-id="671c6-207">Items by priority.</span></span> <span data-ttu-id="671c6-208">Первыми удаляются элементы с наименьшим приоритетом.</span><span class="sxs-lookup"><span data-stu-id="671c6-208">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="671c6-209">Наименее недавно использованные объекты.</span><span class="sxs-lookup"><span data-stu-id="671c6-209">Least recently used objects.</span></span>
* <span data-ttu-id="671c6-210">Элементы с самым ранним абсолютным сроком действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-210">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="671c6-211">Элементы с самой ранней скользящей истечением срока действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-211">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="671c6-212">Закрепленные элементы с приоритетом <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> никогда не удаляются.</span><span class="sxs-lookup"><span data-stu-id="671c6-212">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span> <span data-ttu-id="671c6-213">Следующий код удаляет элемент кэша и вызывает `Compact` :</span><span class="sxs-lookup"><span data-stu-id="671c6-213">The following code removes a cache item and calls `Compact`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="671c6-214">Дополнительные сведения см. [в разделе Compact Source на сайте GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) .</span><span class="sxs-lookup"><span data-stu-id="671c6-214">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="671c6-215">Зависимости кэша</span><span class="sxs-lookup"><span data-stu-id="671c6-215">Cache dependencies</span></span>

<span data-ttu-id="671c6-216">В следующем примере показано, как истечет срок действия записи кэша, если истечет срок действия зависимой записи.</span><span class="sxs-lookup"><span data-stu-id="671c6-216">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="671c6-217"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>Добавляется к кэшированному элементу.</span><span class="sxs-lookup"><span data-stu-id="671c6-217">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="671c6-218">Если `Cancel` метод вызывается для `CancellationTokenSource` , то обе записи кэша будут вытеснены.</span><span class="sxs-lookup"><span data-stu-id="671c6-218">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="671c6-219">Использование <xref:System.Threading.CancellationTokenSource> позволяет удалять несколько записей кэша как группу.</span><span class="sxs-lookup"><span data-stu-id="671c6-219">Using a <xref:System.Threading.CancellationTokenSource> allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="671c6-220">Используя `using` шаблон в приведенном выше коде, записи кэша, созданные внутри `using` блока, будут наследовать параметры триггеров и срока действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-220">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="671c6-221">Дополнительные сведения</span><span class="sxs-lookup"><span data-stu-id="671c6-221">Additional notes</span></span>

* <span data-ttu-id="671c6-222">Истечение срока действия не происходит в фоновом режиме.</span><span class="sxs-lookup"><span data-stu-id="671c6-222">Expiration doesn't happen in the background.</span></span> <span data-ttu-id="671c6-223">Нет таймера, который активно проверяет кэш на наличие просроченных элементов.</span><span class="sxs-lookup"><span data-stu-id="671c6-223">There is no timer that actively scans the cache for expired items.</span></span> <span data-ttu-id="671c6-224">Любое действие в кэше ( `Get` , `Set` , `Remove` ) может активировать фоновое сканирование для элементов с истекшим сроком действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-224">Any activity on the cache (`Get`, `Set`, `Remove`) can trigger a background scan for expired items.</span></span> <span data-ttu-id="671c6-225">Таймер на `CancellationTokenSource` ( <xref:System.Threading.CancellationTokenSource.CancelAfter*> ) также удаляет запись и активирует проверку для элементов с истекшим сроком действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-225">A timer on the `CancellationTokenSource` (<xref:System.Threading.CancellationTokenSource.CancelAfter*>) also removes the entry and triggers a scan for expired items.</span></span> <span data-ttu-id="671c6-226">В следующем примере для зарегистрированного маркера используется [CancellationTokenSource (TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) .</span><span class="sxs-lookup"><span data-stu-id="671c6-226">The following example uses [CancellationTokenSource(TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) for the registered token.</span></span> <span data-ttu-id="671c6-227">Когда этот маркер срабатывает, он немедленно удаляет запись и вызывает обратные вызовы вытеснения:</span><span class="sxs-lookup"><span data-stu-id="671c6-227">When this token fires it removes the entry immediately and fires the eviction callbacks:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ae)]

* <span data-ttu-id="671c6-228">При использовании обратного вызова для повторного заполнения элемента кэша:</span><span class="sxs-lookup"><span data-stu-id="671c6-228">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="671c6-229">Несколько запросов могут найти значение кэшированного ключа пустым, так как обратный вызов не завершен.</span><span class="sxs-lookup"><span data-stu-id="671c6-229">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="671c6-230">Это может привести к повторному заполнению кэшированного элемента несколькими потоками.</span><span class="sxs-lookup"><span data-stu-id="671c6-230">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="671c6-231">Если одна запись кэша используется для создания другой, дочерняя запись копирует маркеры истечения срока действия родительской записи и параметры срока действия, основанные на времени.</span><span class="sxs-lookup"><span data-stu-id="671c6-231">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="671c6-232">Срок действия дочернего элемента не истек, удаление или обновление родительской записи вручную.</span><span class="sxs-lookup"><span data-stu-id="671c6-232">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="671c6-233">Используется <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> для установки обратных вызовов, которые будут срабатывать после удаления записи кэша из кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-233">Use <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>
* <span data-ttu-id="671c6-234">Для большинства приложений `IMemoryCache` включен.</span><span class="sxs-lookup"><span data-stu-id="671c6-234">For most apps, `IMemoryCache` is enabled.</span></span> <span data-ttu-id="671c6-235">Например, вызов метода `AddMvc` ,,, `AddControllersWithViews` `AddRazorPages` `AddMvcCore().AddRazorViewEngine` и многих других `Add{Service}` методов в `ConfigureServices` включает `IMemoryCache` .</span><span class="sxs-lookup"><span data-stu-id="671c6-235">For example, calling `AddMvc`, `AddControllersWithViews`, `AddRazorPages`, `AddMvcCore().AddRazorViewEngine`, and many other `Add{Service}` methods in `ConfigureServices`, enables `IMemoryCache`.</span></span> <span data-ttu-id="671c6-236">Для приложений, которые не вызывают один из вышеперечисленных `Add{Service}` методов, может потребоваться вызвать <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> в `ConfigureServices` .</span><span class="sxs-lookup"><span data-stu-id="671c6-236">For apps that are not calling one of the preceding `Add{Service}` methods, it may be necessary to call <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> in `ConfigureServices`.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="671c6-237">Фоновое обновление кэша</span><span class="sxs-lookup"><span data-stu-id="671c6-237">Background cache update</span></span>

<span data-ttu-id="671c6-238">Используйте [фоновую службу](xref:fundamentals/host/hosted-services) , например, <xref:Microsoft.Extensions.Hosting.IHostedService> для обновления кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-238">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="671c6-239">Фоновая служба может повторно вычислить записи и назначить их кэшу только в том случае, если они готовы.</span><span class="sxs-lookup"><span data-stu-id="671c6-239">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="671c6-240">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="671c6-240">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end

::: moniker range="< aspnetcore-3.0"

<!-- This is the 2.1 version -->
<span data-ttu-id="671c6-241">[Рик Андерсон (](https://twitter.com/RickAndMSFT), [Джон Луо](https://github.com/JunTaoLuo)и [Стив Смит](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="671c6-241">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="671c6-242">[Просмотреть или скачать образец кода](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/performance/caching/memory/sample) ([как скачивать](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="671c6-242">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/performance/caching/memory/sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="671c6-243">Основы кэширования</span><span class="sxs-lookup"><span data-stu-id="671c6-243">Caching basics</span></span>

<span data-ttu-id="671c6-244">Кэширование может значительно повысить производительность и масштабируемость приложения, уменьшая объем работы, необходимый для создания содержимого.</span><span class="sxs-lookup"><span data-stu-id="671c6-244">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="671c6-245">Кэширование лучше всего работает с данными, которые изменяются редко.</span><span class="sxs-lookup"><span data-stu-id="671c6-245">Caching works best with data that changes infrequently.</span></span> <span data-ttu-id="671c6-246">Кэширование создает копию данных, которая может быть возвращена гораздо быстрее, чем из исходного источника.</span><span class="sxs-lookup"><span data-stu-id="671c6-246">Caching makes a copy of data that can be returned much faster than from the original source.</span></span> <span data-ttu-id="671c6-247">Код должен быть написан и протестирован, чтобы **никогда не** зависеть от кэшированных данных.</span><span class="sxs-lookup"><span data-stu-id="671c6-247">Code should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="671c6-248">ASP.NET Core поддерживает несколько разных кэшей.</span><span class="sxs-lookup"><span data-stu-id="671c6-248">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="671c6-249">Простейший кэш основан на [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), который представляет кэш, хранящийся в памяти веб-сервера.</span><span class="sxs-lookup"><span data-stu-id="671c6-249">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), which represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="671c6-250">Приложения, работающие в ферме серверов (несколько серверов), должны обеспечивать работу сеансов при использовании кэша в памяти.</span><span class="sxs-lookup"><span data-stu-id="671c6-250">Apps that run on a server farm (multiple servers) should ensure that sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="671c6-251">Закрепленные сеансы гарантируют, что последующие запросы от клиента поступают на один и тот же сервер.</span><span class="sxs-lookup"><span data-stu-id="671c6-251">Sticky sessions ensure that later requests from a client all go to the same server.</span></span> <span data-ttu-id="671c6-252">Например, веб-приложения Azure используют [маршрутизацию запросов приложений](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) для маршрутизации всех запросов от агента пользователя на один и тот же сервер.</span><span class="sxs-lookup"><span data-stu-id="671c6-252">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all requests from a user agent to the same server.</span></span>

<span data-ttu-id="671c6-253">Для неприкрепленных сеансов в веб-ферме требуется [распределенный кэш](distributed.md) , чтобы избежать проблем с согласованностью кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-253">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="671c6-254">Для некоторых приложений распределенный кэш может поддерживать более высокие возможности масштабирования, чем кэш в памяти.</span><span class="sxs-lookup"><span data-stu-id="671c6-254">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="671c6-255">Использование распределенного кэша разгружает кэш-память во внешний процесс.</span><span class="sxs-lookup"><span data-stu-id="671c6-255">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="671c6-256">Кэш в памяти может хранить любой объект.</span><span class="sxs-lookup"><span data-stu-id="671c6-256">The in-memory cache can store any object.</span></span> <span data-ttu-id="671c6-257">Интерфейс распределенного кэша ограничен `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="671c6-257">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="671c6-258">Элементы кэша в памяти и распределенного кэша хранятся в виде пар "ключ-значение".</span><span class="sxs-lookup"><span data-stu-id="671c6-258">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="671c6-259">System. Runtime. Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="671c6-259">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="671c6-260"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([Пакет NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) можно использовать с:</span><span class="sxs-lookup"><span data-stu-id="671c6-260"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="671c6-261">.NET Standard 2,0 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="671c6-261">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="671c6-262">Любая [реализация .NET](/dotnet/standard/net-standard#net-implementation-support) , предназначенная для .NET Standard 2,0 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="671c6-262">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="671c6-263">Например, ASP.NET Core 2,0 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="671c6-263">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="671c6-264">.NET Framework 4.5 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="671c6-264">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="671c6-265">[Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (описывается в этой статье) рекомендуется использовать, `System.Runtime.Caching` / `MemoryCache` так как он лучше интегрирован в ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="671c6-265">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="671c6-266">Например, `IMemoryCache` работает изначально с [внедрением зависимостей](xref:fundamentals/dependency-injection)ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="671c6-266">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="671c6-267">Используйте `System.Runtime.Caching` / `MemoryCache` в качестве моста совместимости при переносе кода из ASP.NET 4. x в ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="671c6-267">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="671c6-268">Рекомендации по кэшированию</span><span class="sxs-lookup"><span data-stu-id="671c6-268">Cache guidelines</span></span>

* <span data-ttu-id="671c6-269">Код должен всегда иметь резервный вариант для выборки данных и **не** зависит от доступности кэшированного значения.</span><span class="sxs-lookup"><span data-stu-id="671c6-269">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="671c6-270">Кэш использует неограниченный ресурс, память.</span><span class="sxs-lookup"><span data-stu-id="671c6-270">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="671c6-271">Ограничение роста кэша:</span><span class="sxs-lookup"><span data-stu-id="671c6-271">Limit cache growth:</span></span>
  * <span data-ttu-id="671c6-272">**Не** используйте внешние входные данные в качестве ключей кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-272">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="671c6-273">Используйте срок действия, чтобы ограничить рост кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-273">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="671c6-274">[Используйте SetSize, Size и сизелимит для ограничения размера кэша](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="671c6-274">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="671c6-275">Среда выполнения ASP.NET Core не ограничивает размер кэша на основе нехватки памяти.</span><span class="sxs-lookup"><span data-stu-id="671c6-275">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="671c6-276">Разработчик может ограничить размер кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-276">It's up to the developer to limit cache size.</span></span>

## <a name="using-imemorycache"></a><span data-ttu-id="671c6-277">Использование IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="671c6-277">Using IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="671c6-278">Использование кэша *общей* памяти из [внедрения зависимостей](xref:fundamentals/dependency-injection) и вызова `SetSize` , `Size` или `SizeLimit` для ограничения размера кэша может привести к сбою приложения.</span><span class="sxs-lookup"><span data-stu-id="671c6-278">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="671c6-279">Если для кэша задано ограничение размера, все записи должны указывать размер при добавлении.</span><span class="sxs-lookup"><span data-stu-id="671c6-279">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="671c6-280">Это может привести к проблемам, так как разработчики могут не иметь полного контроля над тем, что использует общий кэш.</span><span class="sxs-lookup"><span data-stu-id="671c6-280">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="671c6-281">Например, Entity Framework Core использует общий кэш и не задает размер.</span><span class="sxs-lookup"><span data-stu-id="671c6-281">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="671c6-282">Если приложение устанавливает ограничение размера кэша и использует EF Core, приложение создает исключение `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="671c6-282">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="671c6-283">При использовании `SetSize` , `Size` или `SizeLimit` для ограничения кэша создайте одноэлементный кэш для кэширования.</span><span class="sxs-lookup"><span data-stu-id="671c6-283">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="671c6-284">Дополнительные сведения и пример см. в статьях [Использование SetSize, Size и сизелимит для ограничения размера кэша](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="671c6-284">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>

<span data-ttu-id="671c6-285">Кэширование в памяти — это *Служба* , на которую можно ссылаться из приложения с помощью [внедрения зависимостей](../../fundamentals/dependency-injection.md).</span><span class="sxs-lookup"><span data-stu-id="671c6-285">In-memory caching is a *service* that's referenced from your app using [Dependency Injection](../../fundamentals/dependency-injection.md).</span></span> <span data-ttu-id="671c6-286">Вызов `AddMemoryCache` в `ConfigureServices` :</span><span class="sxs-lookup"><span data-stu-id="671c6-286">Call `AddMemoryCache` in `ConfigureServices`:</span></span>

[!code-csharp[](memory/sample/WebCache/Startup.cs?highlight=9)]

<span data-ttu-id="671c6-287">Запросите `IMemoryCache` экземпляр в конструкторе:</span><span class="sxs-lookup"><span data-stu-id="671c6-287">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="671c6-288">`IMemoryCache` требуется пакет NuGet [Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), доступный в [Microsoft. AspNetCore. app метапакет](xref:fundamentals/metapackage-app).</span><span class="sxs-lookup"><span data-stu-id="671c6-288">`IMemoryCache` requires NuGet package [Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), which is available in the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app).</span></span>

<span data-ttu-id="671c6-289">В следующем коде используется [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) для проверки, находится ли время в кэше.</span><span class="sxs-lookup"><span data-stu-id="671c6-289">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="671c6-290">Если время не кэшировано, создается новая запись и добавляется в кэш с помощью [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="671c6-290">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span>

[!code-csharp[](memory/sample/WebCache/CacheKeys.cs)]

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="671c6-291">Текущее время и кэшированное время отображаются:</span><span class="sxs-lookup"><span data-stu-id="671c6-291">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/sample/WebCache/Views/Home/Cache.cshtml)]

<span data-ttu-id="671c6-292">Кэшированное `DateTime` значение остается в кэше во время выполнения запросов в течение периода ожидания.</span><span class="sxs-lookup"><span data-stu-id="671c6-292">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span> <span data-ttu-id="671c6-293">На следующем рисунке показано текущее время и старое время, полученное из кэша:</span><span class="sxs-lookup"><span data-stu-id="671c6-293">The following image shows the current time and an older time retrieved from the cache:</span></span>

![Представление индекса с двумя различно отображаемым временем](memory/_static/time.png)

<span data-ttu-id="671c6-295">В следующем коде для кэширования данных используются [жеторкреате](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) и [жеторкреатеасинк](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) .</span><span class="sxs-lookup"><span data-stu-id="671c6-295">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="671c6-296">Следующий код вызывает [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) для получения кэшированного времени:</span><span class="sxs-lookup"><span data-stu-id="671c6-296">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="671c6-297"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>методы, и [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) являются методами расширения в классе [качикстенсионс](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) , который расширяет возможности <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="671c6-297"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) are extension methods part of the [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) class that extends the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span> <span data-ttu-id="671c6-298">Описание других методов кэширования см. в разделе [методы IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) и [методы качикстенсионс](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) .</span><span class="sxs-lookup"><span data-stu-id="671c6-298">See [IMemoryCache methods](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) and [CacheExtensions methods](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) for a description of other cache methods.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="671c6-299">меморикачинтрйоптионс</span><span class="sxs-lookup"><span data-stu-id="671c6-299">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="671c6-300">Следующий пример:</span><span class="sxs-lookup"><span data-stu-id="671c6-300">The following sample:</span></span>

* <span data-ttu-id="671c6-301">Задает скользящий срок действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-301">Sets a sliding expiration time.</span></span> <span data-ttu-id="671c6-302">Запросы, обращающиеся к этому кэшированному элементу, будут сбрасывать скользящий срок действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-302">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="671c6-303">Устанавливает для приоритета кэша значение `CacheItemPriority.NeverRemove` .</span><span class="sxs-lookup"><span data-stu-id="671c6-303">Sets the cache priority to `CacheItemPriority.NeverRemove`.</span></span>
* <span data-ttu-id="671c6-304">Задает [постевиктионделегате](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) , который будет вызываться после удаления записи из кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-304">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="671c6-305">Обратный вызов выполняется в другом потоке из кода, который удаляет элемент из кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-305">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="671c6-306">Использование SetSize, Size и Сизелимит для ограничения размера кэша</span><span class="sxs-lookup"><span data-stu-id="671c6-306">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="671c6-307">`MemoryCache`Экземпляр может дополнительно задавать и применять ограничение размера.</span><span class="sxs-lookup"><span data-stu-id="671c6-307">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="671c6-308">Ограничение размера кэша не имеет определенной единицы измерения, так как кэш не имеет механизма для измерения размера записей.</span><span class="sxs-lookup"><span data-stu-id="671c6-308">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="671c6-309">Если установлен предел размера кэша, то для всех записей должен быть указан размер.</span><span class="sxs-lookup"><span data-stu-id="671c6-309">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="671c6-310">Среда выполнения ASP.NET Core не ограничивает размер кэша на основе нехватки памяти.</span><span class="sxs-lookup"><span data-stu-id="671c6-310">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="671c6-311">Разработчик может ограничить размер кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-311">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="671c6-312">Указанный размер находится в единицах, которые выбирает разработчик.</span><span class="sxs-lookup"><span data-stu-id="671c6-312">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="671c6-313">Пример:</span><span class="sxs-lookup"><span data-stu-id="671c6-313">For example:</span></span>

* <span data-ttu-id="671c6-314">Если веб-приложение в основном кэширует строки, каждый размер записи кэша может быть длиной строки.</span><span class="sxs-lookup"><span data-stu-id="671c6-314">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="671c6-315">Приложение может указать размер всех записей как 1, а максимальный размер — число записей.</span><span class="sxs-lookup"><span data-stu-id="671c6-315">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="671c6-316">Если <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> параметр не установлен, кэш растет без привязки.</span><span class="sxs-lookup"><span data-stu-id="671c6-316">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> is not set, the cache grows without bound.</span></span> <span data-ttu-id="671c6-317">При нехватке системной памяти среда выполнения ASP.NET Core не усекает кэш.</span><span class="sxs-lookup"><span data-stu-id="671c6-317">The ASP.NET Core runtime does not trim the cache when system memory is low.</span></span> <span data-ttu-id="671c6-318">Разработка приложений в значительной степени составляет:</span><span class="sxs-lookup"><span data-stu-id="671c6-318">Apps much be architected to:</span></span>

* <span data-ttu-id="671c6-319">Ограничение роста кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-319">Limit cache growth.</span></span>
* <span data-ttu-id="671c6-320">Вызов <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> или <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> Если доступная память ограничена:</span><span class="sxs-lookup"><span data-stu-id="671c6-320">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="671c6-321">В следующем коде создается фиксированный размер независимого <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> от единицы, доступный при [внедрении зависимостей](xref:fundamentals/dependency-injection):</span><span class="sxs-lookup"><span data-stu-id="671c6-321">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="671c6-322">`SizeLimit` не имеет единиц.</span><span class="sxs-lookup"><span data-stu-id="671c6-322">`SizeLimit` does not have units.</span></span> <span data-ttu-id="671c6-323">Кэшированные записи должны указывать размер в любых единицах, которые они считаются наиболее подходящими, если установлен предел размера кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-323">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="671c6-324">Все пользователи экземпляра кэша должны использовать одну и ту же систему единиц измерения.</span><span class="sxs-lookup"><span data-stu-id="671c6-324">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="671c6-325">Запись не будет кэшироваться, если сумма кэшированных размеров записей превышает значение, заданное параметром `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="671c6-325">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="671c6-326">Если ограничение размера кэша не задано, размер кэша, заданный для записи, будет проигнорирован.</span><span class="sxs-lookup"><span data-stu-id="671c6-326">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="671c6-327">Следующий код регистрируется в `MyMemoryCache` контейнере [внедрения зависимостей](xref:fundamentals/dependency-injection) .</span><span class="sxs-lookup"><span data-stu-id="671c6-327">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/sample/RPcache/Startup.cs?name=snippet&highlight=5)]

<span data-ttu-id="671c6-328">`MyMemoryCache` создается как независимый кэш памяти для компонентов, которые знают об этом ограниченном размере кэша и знают, как задать размер записи кэша соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="671c6-328">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="671c6-329">В следующем коде используется `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="671c6-329">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet)]

<span data-ttu-id="671c6-330">Размер записи кэша можно задать по [размеру](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) или методу расширения [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) :</span><span class="sxs-lookup"><span data-stu-id="671c6-330">The size of the cache entry can be set by [Size](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) or the [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) extension method:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="671c6-331">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="671c6-331">MemoryCache.Compact</span></span>

<span data-ttu-id="671c6-332">`MemoryCache.Compact` пытается удалить указанный процент кэша в следующем порядке:</span><span class="sxs-lookup"><span data-stu-id="671c6-332">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="671c6-333">Все элементы с истекшим сроком действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-333">All expired items.</span></span>
* <span data-ttu-id="671c6-334">Элементы по приоритету.</span><span class="sxs-lookup"><span data-stu-id="671c6-334">Items by priority.</span></span> <span data-ttu-id="671c6-335">Первыми удаляются элементы с наименьшим приоритетом.</span><span class="sxs-lookup"><span data-stu-id="671c6-335">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="671c6-336">Наименее недавно использованные объекты.</span><span class="sxs-lookup"><span data-stu-id="671c6-336">Least recently used objects.</span></span>
* <span data-ttu-id="671c6-337">Элементы с самым ранним абсолютным сроком действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-337">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="671c6-338">Элементы с самой ранней скользящей истечением срока действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-338">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="671c6-339">Закрепленные элементы с приоритетом <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> никогда не удаляются.</span><span class="sxs-lookup"><span data-stu-id="671c6-339">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="671c6-340">Дополнительные сведения см. [в разделе Compact Source на сайте GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) .</span><span class="sxs-lookup"><span data-stu-id="671c6-340">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="671c6-341">Зависимости кэша</span><span class="sxs-lookup"><span data-stu-id="671c6-341">Cache dependencies</span></span>

<span data-ttu-id="671c6-342">В следующем примере показано, как истечет срок действия записи кэша, если истечет срок действия зависимой записи.</span><span class="sxs-lookup"><span data-stu-id="671c6-342">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="671c6-343"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>Добавляется к кэшированному элементу.</span><span class="sxs-lookup"><span data-stu-id="671c6-343">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="671c6-344">Если `Cancel` метод вызывается для `CancellationTokenSource` , то обе записи кэша будут вытеснены.</span><span class="sxs-lookup"><span data-stu-id="671c6-344">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="671c6-345">Использование `CancellationTokenSource` позволяет удалять несколько записей кэша как группу.</span><span class="sxs-lookup"><span data-stu-id="671c6-345">Using a `CancellationTokenSource` allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="671c6-346">Используя `using` шаблон в приведенном выше коде, записи кэша, созданные внутри `using` блока, будут наследовать параметры триггеров и срока действия.</span><span class="sxs-lookup"><span data-stu-id="671c6-346">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="671c6-347">Дополнительные сведения</span><span class="sxs-lookup"><span data-stu-id="671c6-347">Additional notes</span></span>

* <span data-ttu-id="671c6-348">При использовании обратного вызова для повторного заполнения элемента кэша:</span><span class="sxs-lookup"><span data-stu-id="671c6-348">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="671c6-349">Несколько запросов могут найти значение кэшированного ключа пустым, так как обратный вызов не завершен.</span><span class="sxs-lookup"><span data-stu-id="671c6-349">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="671c6-350">Это может привести к повторному заполнению кэшированного элемента несколькими потоками.</span><span class="sxs-lookup"><span data-stu-id="671c6-350">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="671c6-351">Если одна запись кэша используется для создания другой, дочерняя запись копирует маркеры истечения срока действия родительской записи и параметры срока действия, основанные на времени.</span><span class="sxs-lookup"><span data-stu-id="671c6-351">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="671c6-352">Срок действия дочернего элемента не истек, удаление или обновление родительской записи вручную.</span><span class="sxs-lookup"><span data-stu-id="671c6-352">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="671c6-353">Используйте [постевиктионкаллбаккс](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) , чтобы задать обратные вызовы, которые будут срабатывать после удаления записи кэша из кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-353">Use [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="671c6-354">Фоновое обновление кэша</span><span class="sxs-lookup"><span data-stu-id="671c6-354">Background cache update</span></span>

<span data-ttu-id="671c6-355">Используйте [фоновую службу](xref:fundamentals/host/hosted-services) , например, <xref:Microsoft.Extensions.Hosting.IHostedService> для обновления кэша.</span><span class="sxs-lookup"><span data-stu-id="671c6-355">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="671c6-356">Фоновая служба может повторно вычислить записи и назначить их кэшу только в том случае, если они готовы.</span><span class="sxs-lookup"><span data-stu-id="671c6-356">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="671c6-357">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="671c6-357">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end
